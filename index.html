<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SVM Interactive Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
    <style>
        body { font-family: 'Noto Sans SC', sans-serif; -webkit-tap-highlight-color: transparent; }
        
        /* Custom Animation */
        .fade-in { animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .pop-in { animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes popIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }

        /* Glassmorphism */
        .glass-panel {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }
        
        /* Slider Styles - Larger touch targets for mobile */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            height: 30px; /* Increased touch area */
            margin: 0;
            touch-action: none; /* Prevent scroll while dragging */
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: #4F46E5;
            cursor: pointer;
            margin-top: -10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 2px solid white;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #E2E8F0;
            border-radius: 2px;
        }

        /* Interactive Terms */
        .term-link {
            border-bottom: 1px dashed #6366f1;
            color: #4f46e5;
            cursor: pointer;
            font-weight: 500;
        }
        .term-link:hover { background-color: rgba(99, 102, 241, 0.1); }

        /* Mobile specific adjustments */
        #canvas-container {
            touch-action: none;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-50 to-indigo-50 min-h-screen flex flex-col md:items-center md:justify-center p-2 md:p-8 text-slate-800">

    <!-- Language Toggle -->
    <button onclick="toggleLanguage()" class="absolute top-4 right-4 z-50 bg-white px-3 py-2 rounded-full shadow-md text-sm font-bold text-slate-600 border border-slate-200 active:scale-95 transition-transform">
        <i class="fa-solid fa-globe mr-1 text-indigo-500"></i> <span id="lang-text">CN</span>
    </button>

    <!-- Term Definition Popup (Hidden by default) -->
    <div id="term-popup" class="fixed inset-0 z-[60] flex items-center justify-center bg-black/20 backdrop-blur-sm hidden" onclick="hideTerm()">
        <div class="bg-white p-6 rounded-2xl shadow-2xl max-w-xs md:max-w-md mx-4 pop-in relative" onclick="event.stopPropagation()">
            <button onclick="hideTerm()" class="absolute top-3 right-3 text-slate-400 hover:text-slate-600">
                <i class="fa-solid fa-xmark text-xl"></i>
            </button>
            <h3 id="term-title" class="text-xl font-bold text-indigo-600 mb-2"></h3>
            <p id="term-desc" class="text-slate-600 text-sm leading-relaxed"></p>
        </div>
    </div>

    <div class="max-w-6xl w-full grid grid-cols-1 lg:grid-cols-12 gap-4 lg:gap-6 h-auto lg:h-[85vh]">
        
        <!-- Left: Visualization Canvas -->
        <div class="lg:col-span-8 bg-white rounded-2xl shadow-xl overflow-hidden relative flex flex-col border border-slate-100 min-h-[40vh] lg:h-full order-2 lg:order-1">
            <!-- Dynamic Feedback Banner (Mobile Friendly) -->
            <div id="feedback-banner" class="absolute top-0 left-0 right-0 p-3 text-center text-sm font-bold transform transition-transform duration-300 -translate-y-full z-20">
                <span id="feedback-text"></span>
            </div>

            <div class="absolute top-4 left-4 z-10 bg-white/90 px-3 py-1 rounded-full text-xs font-mono text-slate-500 shadow-sm border border-slate-200 pointer-events-none" data-key="canvasLabel">
                SVM Visualization Canvas
            </div>
            
            <!-- Canvas Container -->
            <div class="flex-grow relative bg-slate-50" id="canvas-container">
                <canvas id="svmCanvas" class="w-full h-full block"></canvas>
            </div>

            <!-- Bottom Status Bar -->
            <div class="h-auto py-2 md:h-12 border-t border-slate-100 flex flex-col md:flex-row items-center px-4 justify-between bg-white text-xs md:text-sm text-slate-500 gap-2">
                <span id="status-text" class="font-medium" data-key="statusReady">å°±ç»ª</span>
                <div class="flex gap-3 md:gap-4 flex-wrap justify-center">
                    <div class="flex items-center gap-1.5">
                        <span class="w-2.5 h-2.5 rounded-full bg-rose-500"></span> <span data-key="classA">A</span>
                    </div>
                    <div class="flex items-center gap-1.5">
                        <span class="w-2.5 h-2.5 rounded-full bg-blue-500"></span> <span data-key="classB">B</span>
                    </div>
                    <div class="flex items-center gap-1.5">
                        <span class="w-2.5 h-2.5 rounded-full border-2 border-yellow-500 bg-transparent"></span> <span data-key="sv">æ”¯æŒå‘é‡</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right: Control Panel & Tutorial -->
        <div class="lg:col-span-4 flex flex-col gap-4 h-auto lg:h-full order-1 lg:order-2">
            
            <!-- Title Card -->
            <div class="glass-panel p-5 rounded-2xl shadow-lg">
                <div class="flex items-center justify-between mb-2">
                    <h1 class="text-xl md:text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-indigo-600 to-purple-600" data-key="mainTitle">
                        æ”¯æŒå‘é‡æœº SVM
                    </h1>
                    <i class="fa-solid fa-brain text-indigo-500 text-xl"></i>
                </div>
                <!-- Interactive explanation with clickable terms -->
                <p class="text-slate-600 text-sm leading-relaxed" id="intro-desc">
                    <!-- Content injected by JS -->
                </p>
            </div>

            <!-- Interactive Control Area -->
            <div class="glass-panel p-5 rounded-2xl shadow-lg flex-grow flex flex-col relative overflow-hidden min-h-[300px]">
                
                <!-- Step Navigation -->
                <div class="flex justify-between mb-4 border-b border-slate-200 pb-2 overflow-x-auto">
                    <button onclick="setStep(0)" class="step-btn whitespace-nowrap text-xs font-bold px-3 py-1.5 rounded-full bg-indigo-100 text-indigo-700 transition-colors mr-1" data-step="0" data-key="step0Btn">1. æ•°æ®</button>
                    <button onclick="setStep(1)" class="step-btn whitespace-nowrap text-xs font-bold px-3 py-1.5 rounded-full text-slate-500 hover:bg-slate-100 transition-colors mr-1" data-step="1" data-key="step1Btn">2. å†³ç­–è¾¹ç•Œ</button>
                    <button onclick="setStep(2)" class="step-btn whitespace-nowrap text-xs font-bold px-3 py-1.5 rounded-full text-slate-500 hover:bg-slate-100 transition-colors mr-1" data-step="2" data-key="step2Btn">3. æœ€ä¼˜è§£</button>
                    <button onclick="setStep(3)" class="step-btn whitespace-nowrap text-xs font-bold px-3 py-1.5 rounded-full text-slate-500 hover:bg-slate-100 transition-colors" data-step="3" data-key="step3Btn">4. è¯•ä¸€è¯•</button>
                </div>

                <!-- Content Area -->
                <div id="content-area" class="flex-grow relative">
                    
                    <!-- Step 0: Data Intro -->
                    <div class="step-content absolute inset-0 fade-in" id="step-0">
                        <h3 class="font-bold text-lg mb-2 text-slate-800" data-key="step0Title">æ··ä¹±çš„æ•°æ®ç‚¹</h3>
                        <p class="text-sm text-slate-600 mb-4" data-key="step0Desc">
                            æƒ³è±¡è¿™æ˜¯ä¸¤ç§ä¸åŒç±»å‹çš„ç»†èƒï¼Œæˆ–è€…åƒåœ¾é‚®ä»¶ä¸æ­£å¸¸é‚®ä»¶çš„ç‰¹å¾åˆ†å¸ƒã€‚<br><br>
                            æˆ‘ä»¬çš„ä»»åŠ¡æ˜¯ç”»ä¸€æ¡ç›´çº¿ï¼ŒæŠŠçº¢çƒå’Œè“çƒå®Œå…¨åˆ†å¼€ã€‚
                        </p>
                        <div class="bg-indigo-50 p-3 rounded-lg border border-indigo-100 text-sm text-indigo-800 flex items-start">
                            <i class="fa-solid fa-lightbulb mt-1 mr-2 flex-shrink-0"></i> 
                            <span data-key="step0Hint">æç¤ºï¼šç‚¹å‡»â€œå†³ç­–è¾¹ç•Œâ€çœ‹çœ‹æ€ä¹ˆåˆ†ã€‚</span>
                        </div>
                    </div>

                    <!-- Step 1: Decision Boundary -->
                    <div class="step-content absolute inset-0 opacity-0 pointer-events-none transition-opacity duration-300" id="step-1">
                        <h3 class="font-bold text-lg mb-2 text-slate-800" data-key="step1Title">æ— æ•°ç§åˆ†æ³•</h3>
                        <p class="text-sm text-slate-600 mb-4" id="step1-desc">
                            <!-- Injected JS -->
                        </p>
                        <div class="bg-rose-50 p-3 rounded-lg border border-rose-100 text-sm text-rose-800 flex items-start">
                            <i class="fa-solid fa-triangle-exclamation mt-1 mr-2 flex-shrink-0"></i> 
                            <span data-key="step1Hint">é—®é¢˜ï¼šç¦»æ•°æ®ç‚¹å¤ªè¿‘ï¼Œ<b>é²æ£’æ€§</b>å·®ã€‚</span>
                        </div>
                    </div>

                    <!-- Step 2: Margin & Support Vectors -->
                    <div class="step-content absolute inset-0 opacity-0 pointer-events-none transition-opacity duration-300" id="step-2">
                        <h3 class="font-bold text-lg mb-2 text-slate-800" data-key="step2Title">å¯»æ‰¾æœ€å¤§é—´éš”</h3>
                        <p class="text-sm text-slate-600 mb-4" id="step2-desc">
                            <!-- Injected JS -->
                        </p>
                        <ul class="text-xs md:text-sm text-slate-600 space-y-2 mb-4 list-none pl-1" id="step2-list">
                           <!-- Injected JS -->
                        </ul>
                        <div class="bg-emerald-50 p-3 rounded-lg border border-emerald-100 text-sm text-emerald-800 flex items-start">
                            <i class="fa-solid fa-check mt-1 mr-2 flex-shrink-0"></i> 
                            <span data-key="step2Hint">åªæœ‰æ”¯æŒå‘é‡å†³å®šäº†è·¯çš„ä½ç½®ï¼Œå…¶ä»–ç‚¹ä¸é‡è¦ï¼</span>
                        </div>
                    </div>

                    <!-- Step 3: Interactive Challenge -->
                    <div class="step-content absolute inset-0 opacity-0 pointer-events-none transition-opacity duration-300" id="step-3">
                        <h3 class="font-bold text-lg mb-2 text-slate-800 flex items-center gap-2">
                            <span data-key="step3Title">æ‰‹åŠ¨ SVM æŒ‘æˆ˜</span>
                            <span class="text-xs bg-indigo-100 text-indigo-600 px-2 py-0.5 rounded-full">Interactive</span>
                        </h3>
                        <p class="text-sm text-slate-600 mb-4" data-key="step3Desc">
                            è¯•ç€è°ƒèŠ‚æ»‘å—ã€‚ç›®æ ‡ï¼š<br>1. åˆ†å¼€çº¢è“ç‚¹ã€‚<br>2. è®©ä¸­é—´çš„ç»¿è‰²åŒºåŸŸå°½å¯èƒ½å®½ã€‚
                        </p>
                        
                        <div class="space-y-5 bg-slate-50 p-4 rounded-xl border border-slate-200">
                            <div>
                                <label class="flex justify-between text-xs font-bold text-slate-500 mb-2">
                                    <span data-key="slope">æ—‹è½¬è§’åº¦</span> <span id="angle-val" class="bg-white px-2 rounded border">45Â°</span>
                                </label>
                                <input type="range" id="angle-slider" min="0" max="180" value="45" step="1" oninput="manualUpdate()">
                            </div>
                            <div>
                                <label class="flex justify-between text-xs font-bold text-slate-500 mb-2">
                                    <span data-key="bias">ä½ç½®åç§»</span> <span id="bias-val" class="bg-white px-2 rounded border">0</span>
                                </label>
                                <input type="range" id="bias-slider" min="-300" max="300" value="0" step="1" oninput="manualUpdate()">
                            </div>
                        </div>
                        
                        <div id="margin-score" class="mt-4 text-center font-mono font-bold text-xl text-slate-300 transition-colors duration-300">
                            Margin: 0.00
                        </div>
                    </div>

                </div>

            </div>
        </div>
    </div>

    <script>
        // --- 1. Config & Localization with Glossary ---
        
        const terms = {
            zh: {
                optimalBoundary: { title: "æœ€ä¼˜è¾¹ç•Œ (Optimal Boundary)", desc: "åœ¨æ‰€æœ‰å¯èƒ½çš„åˆ†ç±»çº¿ä¸­ï¼Œèƒ½å¤Ÿæœ€å¤§ç¨‹åº¦åŒºåˆ†ä¸¤ç±»æ•°æ®çš„çº¿ã€‚å®ƒå¯¹æœªæ¥çš„æœªçŸ¥æ•°æ®æœ‰æœ€å¥½çš„é¢„æµ‹èƒ½åŠ›ã€‚" },
                robustness: { title: "é²æ£’æ€§ (Robustness)", desc: "æ¨¡å‹çš„æŠ—å¹²æ‰°èƒ½åŠ›ã€‚å¦‚æœä¸€æ¡åˆ†ç±»çº¿ç¦»æ•°æ®ç‚¹å¤ªè¿‘ï¼Œç¨å¾®æœ‰ä¸€ç‚¹å™ªéŸ³æˆ–æ–°æ•°æ®ï¼Œåˆ†ç±»å°±ä¼šå‡ºé”™ï¼Œè¿™å°±å«é²æ£’æ€§å·®ã€‚" },
                hyperplane: { title: "è¶…å¹³é¢ (Hyperplane)", desc: "åœ¨äºŒç»´ç©ºé—´æ˜¯ç›´çº¿ï¼Œåœ¨ä¸‰ç»´ç©ºé—´æ˜¯å¹³é¢ï¼Œåœ¨é«˜ç»´ç©ºé—´å«è¶…å¹³é¢ã€‚å®ƒæ˜¯åˆ†å‰²æ•°æ®çš„â€œåˆ€â€ã€‚" },
                margin: { title: "é—´éš” (Margin)", desc: "è¶…å¹³é¢åˆ°æœ€è¿‘çš„æ•°æ®ç‚¹ï¼ˆæ”¯æŒå‘é‡ï¼‰ä¹‹é—´çš„è·ç¦»ã€‚SVM çš„ç›®æ ‡å°±æ˜¯è®©è¿™ä¸ªè·ç¦»æœ€å¤§åŒ–ã€‚" },
                supportVectors: { title: "æ”¯æŒå‘é‡ (Support Vectors)", desc: "ç¦»è¶…å¹³é¢æœ€è¿‘çš„é‚£äº›æ•°æ®ç‚¹ã€‚å®ƒä»¬åƒæŸ±å­ä¸€æ ·â€œæ”¯æ’‘â€ç€è¶…å¹³é¢ã€‚å¦‚æœç§»é™¤éæ”¯æŒå‘é‡çš„ç‚¹ï¼Œè¶…å¹³é¢ä¸ä¼šæ”¹å˜ã€‚" }
            },
            en: {
                optimalBoundary: { title: "Optimal Boundary", desc: "The line that best separates the two classes of data among all possibilities. It offers the best prediction for future unknown data." },
                robustness: { title: "Robustness", desc: "The ability to withstand errors. If a line is too close to data points, slight noise can cause misclassification. This is poor robustness." },
                hyperplane: { title: "Hyperplane", desc: "A line in 2D, a plane in 3D, and a hyperplane in higher dimensions. It acts as the 'knife' that separates the data." },
                margin: { title: "Margin", desc: "The distance between the hyperplane and the closest data points (Support Vectors). SVM aims to maximize this width." },
                supportVectors: { title: "Support Vectors", desc: "The data points closest to the hyperplane. They 'support' or define the boundary. Removing other points won't change the boundary." }
            }
        };

        const i18n = {
            zh: {
                title: "SVM äº¤äº’å¼å¯è§†åŒ–æ¢ç´¢",
                canvasLabel: "SVM å¯è§†åŒ–ç”»å¸ƒ",
                statusReady: "å°±ç»ª",
                classA: "A",
                classB: "B",
                sv: "æ”¯æŒå‘é‡",
                mainTitle: "æ”¯æŒå‘é‡æœº SVM",
                // Rich text with terms
                introDesc: `SVM æ˜¯ä¸€ç§å¯»æ‰¾ <span class="term-link" onclick="showTerm('optimalBoundary')">æœ€ä¼˜è¾¹ç•Œ (?)</span> çš„åˆ†ç±»ç®—æ³•ã€‚å®ƒçš„ç›®æ ‡ä¸ä»…æ˜¯åˆ†å¼€æ•°æ®ï¼Œè€Œæ˜¯æ‰¾åˆ°ä¸€æ¡â€œè·¯â€ï¼Œè®©è¿™æ¡è·¯å°½å¯èƒ½å®½ã€‚`,
                step0Btn: "1. æ•°æ®",
                step1Btn: "2. å†³ç­–è¾¹ç•Œ",
                step2Btn: "3. æœ€ä¼˜è§£",
                step3Btn: "4. è¯•ä¸€è¯•",
                step0Title: "æ··ä¹±çš„æ•°æ®ç‚¹",
                step0Desc: "æƒ³è±¡è¿™æ˜¯ä¸¤ç§ä¸åŒç±»å‹çš„ç»†èƒï¼Œæˆ–è€…åƒåœ¾é‚®ä»¶ä¸æ­£å¸¸é‚®ä»¶çš„ç‰¹å¾åˆ†å¸ƒã€‚<br><br>æˆ‘ä»¬çš„ä»»åŠ¡æ˜¯ç”»ä¸€æ¡ç›´çº¿ï¼ŒæŠŠçº¢çƒå’Œè“çƒå®Œå…¨åˆ†å¼€ã€‚",
                step0Hint: "æç¤ºï¼šç‚¹å‡»â€œå†³ç­–è¾¹ç•Œâ€çœ‹çœ‹æ€ä¹ˆåˆ†ã€‚",
                step1Title: "æ— æ•°ç§åˆ†æ³•",
                step1Desc: `åªè¦èƒ½åˆ†å¼€çº¢è“ä¸¤ç»„ï¼Œä»»ä½•ç›´çº¿éƒ½æ˜¯åˆæ ¼çš„â€œåˆ†ç±»å™¨â€ã€‚<br><br>ä½†æ˜¯ï¼Œæœ‰äº›çº¿ç¦»æ•°æ®ç‚¹å¤ªè¿‘äº†ã€‚å¦‚æœæ–°æ¥ä¸€ä¸ªæ•°æ®ç‚¹ç¨å¾®åä¸€ç‚¹ï¼Œå°±å®¹æ˜“åˆ†é”™ã€‚`,
                step1Hint: `é—®é¢˜ï¼šç¦»æ•°æ®ç‚¹å¤ªè¿‘ï¼Œ<span class="term-link font-bold underline decoration-dotted" onclick="showTerm('robustness')">é²æ£’æ€§ (?)</span> å·®ã€‚`,
                step2Title: "å¯»æ‰¾æœ€å¤§é—´éš”",
                step2Desc: `SVM çš„æ ¸å¿ƒé­”æ³•ï¼šæˆ‘ä»¬è¦æ‰¾ä¸€æ¡è·¯ï¼Œè¿™æ¡è·¯åœ¨ä¸ç¢°åˆ°ä»»ä½•çƒçš„å‰æä¸‹ï¼Œ<b>è¶Šå®½è¶Šå¥½</b>ã€‚`,
                step2List: `<li><span class="term-link" onclick="showTerm('hyperplane')">è¶…å¹³é¢ (?)</span>: è·¯ä¸­é—´çš„å®çº¿ã€‚</li><li><span class="term-link" onclick="showTerm('margin')">é—´éš” (?)</span>: è·¯çš„å®½åº¦ã€‚</li><li><span class="term-link" onclick="showTerm('supportVectors')">æ”¯æŒå‘é‡ (?)</span>: é‚£äº›â€œæ’‘â€èµ·è·¯è¾¹çº¿çš„å…³é”®ç‚¹ã€‚</li>`,
                step2Hint: "åªæœ‰æ”¯æŒå‘é‡å†³å®šäº†è·¯çš„ä½ç½®ï¼Œå…¶ä»–ç‚¹ä¸é‡è¦ï¼",
                step3Title: "æ‰‹åŠ¨ SVM æŒ‘æˆ˜",
                step3Desc: "è¯•ç€è°ƒèŠ‚æ»‘å—ã€‚ç›®æ ‡ï¼š<br>1. åˆ†å¼€çº¢è“ç‚¹ã€‚<br>2. è®©ä¸­é—´çš„ç»¿è‰²åŒºåŸŸå°½å¯èƒ½å®½ã€‚",
                slope: "æ—‹è½¬è§’åº¦",
                bias: "ä½ç½®åç§»",
                statusStep1: "ä¸€èˆ¬çš„åˆ†ç±»çº¿",
                statusStep2: "æœ€ä¼˜è¶…å¹³é¢",
                statusStep3: "æ‰‹åŠ¨æ¢ç´¢æ¨¡å¼",
                error: "âš ï¸ åˆ†ç±»é”™è¯¯! é‡å äº†",
                margin: "Margin: ",
                feedbackSuccess: "âœ… å®Œç¾åˆ†ç¦»ï¼é—´éš”å®½åº¦: ",
                feedbackFail: "âš ï¸ å‘ç”Ÿç¢°æ’ï¼æ— æ³•åˆ†ç±»",
                feedbackOptimal: "ğŸ† ä½ æ‰¾åˆ°äº†æœ€ä¼˜è§£ï¼"
            },
            en: {
                title: "Interactive SVM Explorer",
                canvasLabel: "SVM Visualization Canvas",
                statusReady: "Ready",
                classA: "A",
                classB: "B",
                sv: "Supp. Vec.",
                mainTitle: "Support Vector Machine",
                introDesc: `SVM is an algorithm finding the <span class="term-link" onclick="showTerm('optimalBoundary')">Optimal Boundary (?)</span>. Its goal is a path as wide as possible.`,
                step0Btn: "1. Data",
                step1Btn: "2. Boundary",
                step2Btn: "3. Optimal",
                step3Btn: "4. Try It",
                step0Title: "The Data Points",
                step0Desc: "Imagine these are two types of cells, or spam vs. normal emails.<br><br>Our task is to draw a line to separate red and blue dots.",
                step0Hint: "Tip: Click 'Boundary' to see how.",
                step1Title: "Infinite Possibilities",
                step1Desc: `Any line separating the groups works. <br><br>But lines too close to points are risky. New points might be misclassified.`,
                step1Hint: `Problem: Poor <span class="term-link font-bold underline decoration-dotted" onclick="showTerm('robustness')">Robustness (?)</span>.`,
                step2Title: "Max Margin",
                step2Desc: `SVM Magic: Find a path that is <b>as wide as possible</b> without touching dots.`,
                step2List: `<li><span class="term-link" onclick="showTerm('hyperplane')">Hyperplane (?)</span>: The middle line.</li><li><span class="term-link" onclick="showTerm('margin')">Margin (?)</span>: Path width.</li><li><span class="term-link" onclick="showTerm('supportVectors')">Support Vectors (?)</span>: Key points supporting the edges.</li>`,
                step2Hint: "Only Support Vectors matter!",
                step3Title: "Manual SVM Challenge",
                step3Desc: "Adjust sliders. Goal:<br>1. Separate red/blue.<br>2. Maximize the green width.",
                slope: "Angle",
                bias: "Position",
                statusStep1: "General Boundary",
                statusStep2: "Optimal Hyperplane",
                statusStep3: "Manual Mode",
                error: "âš ï¸ Collision! Overlap",
                margin: "Margin: ",
                feedbackSuccess: "âœ… Separated! Margin: ",
                feedbackFail: "âš ï¸ Collision! Can't separate",
                feedbackOptimal: "ğŸ† Optimal Solution Found!"
            }
        };

        let currentLang = 'en';
        let lastSeparatedState = false; 

        // --- Terminology Popup Logic ---
        function showTerm(termKey) {
            const data = terms[currentLang][termKey];
            document.getElementById('term-title').innerText = data.title;
            document.getElementById('term-desc').innerText = data.desc;
            const popup = document.getElementById('term-popup');
            popup.classList.remove('hidden');
        }

        function hideTerm() {
            document.getElementById('term-popup').classList.add('hidden');
        }

        function toggleLanguage() {
            currentLang = currentLang === 'zh' ? 'en' : 'zh';
            const btnText = document.getElementById('lang-text');
            btnText.innerText = currentLang === 'zh' ? 'English' : 'ä¸­æ–‡';
            
            applyLanguage();
            if(currentStep === 3) manualUpdate();
        }

        function applyLanguage() {
            document.querySelectorAll('[data-key]').forEach(el => {
                const key = el.getAttribute('data-key');
                if (i18n[currentLang][key]) {
                    el.innerHTML = i18n[currentLang][key];
                }
            });
            document.getElementById('intro-desc').innerHTML = i18n[currentLang].introDesc;
            document.getElementById('step1-desc').innerHTML = i18n[currentLang].step1Desc;
            document.getElementById('step2-desc').innerHTML = i18n[currentLang].step2Desc;
            document.getElementById('step2-list').innerHTML = i18n[currentLang].step2List;
            
            updateStatusText();
        }

        function updateStatusText() {
            const statusEl = document.getElementById('status-text');
            if (currentStep === 0) statusEl.innerText = i18n[currentLang].statusReady;
            else if (currentStep === 1) statusEl.innerText = i18n[currentLang].statusStep1;
            else if (currentStep === 2) statusEl.innerText = i18n[currentLang].statusStep2;
            else if (currentStep === 3) statusEl.innerText = i18n[currentLang].statusStep3;
        }

        // --- 2. Canvas & SVM Logic ---

        const canvas = document.getElementById('svmCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        let currentStep = 0;
        let width, height;
        let points = [];
        const POINT_RADIUS = 7; 
        
        const rawDataA = [
            {x: 0.2, y: 0.6}, {x: 0.3, y: 0.7}, {x: 0.1, y: 0.8}, 
            {x: 0.4, y: 0.6}, {x: 0.25, y: 0.5}, {x: 0.15, y: 0.65}
        ];
        const rawDataB = [
            {x: 0.7, y: 0.3}, {x: 0.8, y: 0.2}, {x: 0.6, y: 0.4}, 
            {x: 0.75, y: 0.45}, {x: 0.9, y: 0.15}, {x: 0.65, y: 0.25}
        ];

        let animationFrame;
        let targetAngle = -45;
        let currentAngle = -45;
        let targetBias = 0;
        let currentBias = 0;
        
        // Updated constants for Centered Coordinates
        // Optimal angle: 135 deg (approx diagonal separation)
        // Optimal bias: 0 (since data is centered)
        const OPTIMAL_ANGLE = 135;
        const OPTIMAL_BIAS = 0;
        
        // Bad Angle: 110 deg
        // Bad Bias: needs to be shifted to hit points. 
        // Relative to center, maybe +120px
        const BAD_ANGLE = 110;
        const BAD_BIAS = 120;

        function resize() {
            width = container.clientWidth;
            height = container.clientHeight;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            mapPointsToScreen();
            draw();
        }

        function mapPointsToScreen() {
            points = [];
            rawDataA.forEach(p => {
                points.push({ x: p.x * width, y: (1 - p.y) * height, type: 'A' });
            });
            rawDataB.forEach(p => {
                points.push({ x: p.x * width, y: (1 - p.y) * height, type: 'B' });
            });
        }

        function getDist(px, py, angleDeg, bias) {
            const rad = angleDeg * Math.PI / 180;
            const nx = Math.sin(rad);
            const ny = -Math.cos(rad);
            
            // KEY FIX: Use Center-Relative Coordinates
            const dx = px - width / 2;
            const dy = py - height / 2;
            
            return nx * dx + ny * dy + bias;
        }

        function drawGrid() {
            ctx.strokeStyle = '#f1f5f9';
            ctx.lineWidth = 1;
            const step = 40;
            ctx.beginPath();
            for(let x=0; x<width; x+=step) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
            for(let y=0; y<height; y+=step) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
            ctx.stroke();
        }

        function drawPoints(highlightSupportVectors = false, lineAngle = 0, lineBias = 0) {
            let minDistA = Infinity;
            let minDistB = Infinity;
            
            if (highlightSupportVectors) {
                points.forEach(p => {
                    const dist = getDist(p.x, p.y, lineAngle, lineBias);
                    if (p.type === 'A') {
                        if (dist > 0 && dist < minDistA) minDistA = dist;
                        if (dist < 0 && -dist < minDistA) minDistA = -dist;
                    } else {
                        if (dist > 0 && dist < minDistB) minDistB = dist;
                        if (dist < 0 && -dist < minDistB) minDistB = -dist;
                    }
                });
            }

            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, POINT_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = p.type === 'A' ? '#F43F5E' : '#3B82F6';
                ctx.fill();
                
                if (highlightSupportVectors) {
                    const dist = Math.abs(getDist(p.x, p.y, lineAngle, lineBias));
                    const isSupportVector = 
                        (p.type === 'A' && Math.abs(dist - minDistA) < 2) || 
                        (p.type === 'B' && Math.abs(dist - minDistB) < 2);
                    
                    if (isSupportVector) {
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = '#EAB308';
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, POINT_RADIUS + 5, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(234, 179, 8, 0.6)';
                        ctx.stroke();
                    }
                }
            });

            return Math.min(minDistA, minDistB);
        }

        function drawSVM(angle, bias, showMargin = false) {
            const rad = angle * Math.PI / 180;
            const nx = Math.sin(rad);
            const ny = -Math.cos(rad);
            
            // Draw hyperplane using CENTERED coordinates
            // Formula: nx * (x - cx) + ny * (y - cy) + bias = 0
            // y - cy = ( -bias - nx * (x - cx) ) / ny
            // y = cy + ( -bias - nx * (x - cx) ) / ny
            
            const cx = width / 2;
            const cy = height / 2;

            ctx.beginPath();
            
            // Handle vertical line case (ny near 0)
            if (Math.abs(ny) < 0.01) {
                // nx * (x - cx) + bias = 0  => x = cx - bias/nx
                const verticalX = cx - bias / nx;
                ctx.moveTo(verticalX, 0);
                ctx.lineTo(verticalX, height);
            } else {
                // Draw across a wide range to cover rotations
                let started = false;
                for(let x=-width; x<=width*2; x+=20) {
                     const y = cy + ( -bias - nx * (x - cx) ) / ny;
                    if(!started) { ctx.moveTo(x, y); started = true; }
                    else { ctx.lineTo(x, y); }
                }
            }
            
            ctx.strokeStyle = '#475569';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.stroke();

            if (showMargin) {
                const margin = drawPoints(true, angle, bias);
                
                if (margin !== Infinity) {
                    // Margin Lines
                    ctx.beginPath();
                    
                    if (Math.abs(ny) < 0.01) {
                         const vX1 = cx - (bias + margin) / nx;
                         const vX2 = cx - (bias - margin) / nx;
                         ctx.moveTo(vX1, 0); ctx.lineTo(vX1, height);
                         ctx.moveTo(vX2, 0); ctx.lineTo(vX2, height); // Separate paths needed really but stroke handles MoveTo
                    } else {
                         // Line 1
                        let started = false;
                        for(let x=-width; x<=width*2; x+=20) {
                            const y = cy + ( -(bias + margin) - nx * (x - cx) ) / ny;
                            if(!started) { ctx.moveTo(x, y); started = true; }
                            else { ctx.lineTo(x, y); }
                        }
                        // Line 2 (Start new sub-path implicitly by MoveTo in next loop? No, need to handle properly)
                         // Actually canvas stroke() draws all subpaths.
                        started = false; 
                        // Note: The previous loop left the pen at last point. We need moveTo for second line.
                        // My previous code relied on !started flag which resets for each loop if I did 2 loops.
                        // Let's do 2 separate loops or set stroke twice? 
                        // Easiest: ctx.stroke(); ctx.beginPath(); ...
                    }
                    ctx.strokeStyle = 'rgba(79, 70, 229, 0.4)';
                    ctx.setLineDash([8, 6]);
                    ctx.stroke();

                    // Second margin line explicitly
                    ctx.beginPath();
                     if (Math.abs(ny) < 0.01) {
                         const vX2 = cx - (bias - margin) / nx;
                         ctx.moveTo(vX2, 0); ctx.lineTo(vX2, height);
                     } else {
                        let started = false;
                        for(let x=-width; x<=width*2; x+=20) {
                            const y = cy + ( -(bias - margin) - nx * (x - cx) ) / ny;
                            if(!started) { ctx.moveTo(x, y); started = true; }
                            else { ctx.lineTo(x, y); }
                        }
                     }
                    ctx.stroke();

                    // Score & Feedback Update
                    if(currentStep === 3) {
                        const signA = Math.sign(getDist(points[0].x, points[0].y, angle, bias));
                        let separated = true;
                        
                        const firstBIndex = points.findIndex(p => p.type === 'B');
                        const signB = Math.sign(getDist(points[firstBIndex].x, points[firstBIndex].y, angle, bias));

                        points.forEach(p => {
                            const d = getDist(p.x, p.y, angle, bias);
                            if(p.type === 'A' && Math.sign(d) !== signA) separated = false;
                            if(p.type === 'B' && Math.sign(d) !== signB) separated = false;
                        });

                        const scoreEl = document.getElementById('margin-score');
                        const feedbackEl = document.getElementById('feedback-text');
                        const feedbackBanner = document.getElementById('feedback-banner');

                        // Haptic Feedback trigger
                        if (separated !== lastSeparatedState) {
                            if (window.navigator && window.navigator.vibrate) {
                                window.navigator.vibrate(50); 
                            }
                            lastSeparatedState = separated;
                        }

                        if(!separated) {
                            scoreEl.innerText = i18n[currentLang].error;
                            scoreEl.className = "mt-4 text-center font-mono font-bold text-xl text-rose-500";
                            
                            feedbackEl.innerText = i18n[currentLang].feedbackFail;
                            feedbackBanner.className = "absolute top-0 left-0 right-0 p-3 text-center text-sm font-bold transform transition-transform duration-300 z-20 bg-rose-500 text-white shadow-md";
                            feedbackBanner.style.transform = "translateY(0)";
                        } else {
                            scoreEl.innerText = `${i18n[currentLang].margin}${margin.toFixed(1)}`;
                            const intensity = Math.min(margin, 50) / 50; 
                            scoreEl.style.color = `rgba(16, 185, 129, ${0.5 + intensity/2})`;
                            scoreEl.className = "mt-4 text-center font-mono font-bold text-xl";
                            
                            feedbackEl.innerText = `${i18n[currentLang].feedbackSuccess}${margin.toFixed(1)}`;
                            feedbackBanner.className = "absolute top-0 left-0 right-0 p-3 text-center text-sm font-bold transform transition-transform duration-300 z-20 bg-emerald-500 text-white shadow-md";
                            feedbackBanner.style.transform = "translateY(0)";
                        }
                    } else {
                         document.getElementById('feedback-banner').style.transform = "translateY(-100%)";
                    }
                }
            } else {
                drawPoints(false);
                document.getElementById('feedback-banner').style.transform = "translateY(-100%)";
            }
        }

        function draw() {
            const dpr = window.devicePixelRatio || 1;
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.restore();

            drawGrid();

            if (currentStep !== 3) {
                currentAngle = currentAngle + (targetAngle - currentAngle) * 0.1;
                currentBias = currentBias + (targetBias - currentBias) * 0.1;
            } else {
                currentAngle = parseFloat(document.getElementById('angle-slider').value);
                // No scaling for bias anymore, treat as direct pixels relative to center
                currentBias = parseFloat(document.getElementById('bias-slider').value);
            }

            if (currentStep === 0) {
                drawPoints(false);
            } else if (currentStep === 1) {
                drawSVM(currentAngle, currentBias, false);
            } else if (currentStep === 2) {
                drawSVM(currentAngle, currentBias, true);
            } else if (currentStep === 3) {
                drawSVM(currentAngle, currentBias, true);
            }

            animationFrame = requestAnimationFrame(draw);
        }

        // --- 3. Interaction ---

        function setStep(step) {
            currentStep = step;
            updateStatusText();
            
            document.querySelectorAll('.step-btn').forEach(btn => {
                const s = parseInt(btn.dataset.step);
                if(s === step) {
                    btn.classList.remove('text-slate-500', 'hover:bg-slate-100');
                    btn.classList.add('bg-indigo-100', 'text-indigo-700', 'shadow-sm');
                } else {
                    btn.classList.add('text-slate-500', 'hover:bg-slate-100');
                    btn.classList.remove('bg-indigo-100', 'text-indigo-700', 'shadow-sm');
                }
            });

            document.querySelectorAll('.step-content').forEach(el => {
                el.style.opacity = '0';
                el.style.pointerEvents = 'none';
                el.classList.remove('fade-in');
            });
            const activeContent = document.getElementById(`step-${step}`);
            activeContent.style.opacity = '1';
            activeContent.style.pointerEvents = 'auto';
            activeContent.classList.add('fade-in');

             document.getElementById('feedback-banner').style.transform = "translateY(-100%)";

            if (step === 0) {
                // Just points
            } else if (step === 1) {
                targetAngle = BAD_ANGLE;
                targetBias = BAD_BIAS;
            } else if (step === 2) {
                targetAngle = OPTIMAL_ANGLE;
                targetBias = OPTIMAL_BIAS; 
            } else if (step === 3) {
                // Reset manual mode to a neutral but "unsolved" state
                document.getElementById('angle-slider').value = 90; // Vertical
                document.getElementById('bias-slider').value = 0;   // Centered
                manualUpdate();
            }
        }

        function manualUpdate() {
            if(currentStep !== 3) return;
            const angle = document.getElementById('angle-slider').value;
            const bias = document.getElementById('bias-slider').value;
            document.getElementById('angle-val').innerText = angle + "Â°";
            document.getElementById('bias-val').innerText = bias;
        }

        window.addEventListener('resize', resize);
        
        applyLanguage();
        resize(); 
        draw(); 
        
    </script>
</body>
</html>
